/*
	Copyright (C) 2007 Quentin Mathe
 
	Author:  Quentin Mathe <qmathe@club-internet.fr>
	Date:  January 2007
	License:  Modified BSD  (see COPYING)
 */

#import <EtoileFoundation/Macros.h>
#import <EtoileFoundation/ETUTI.h>
#import "ETController.h"
#import "ETLayoutItemGroup+Mutation.h"
#import "ETContainer.h"
#import "ETLayoutItemGroup.h"
#import "ETCompatibility.h"


@implementation ETController

- (id) init
{
	SUPERINIT

	[self setSortDescriptors: nil];
	_allowedPickType = [[ETUTI alloc] init];
	_allowedDropTypes = [[NSMutableDictionary alloc] init];

	return self;
}

- (void) dealloc
{
	DESTROY(_templateItem); 
	DESTROY(_templateItemGroup); 
	DESTROY(_objectClass); 
	DESTROY(_groupClass);
	DESTROY(_sortDescriptors);
	DESTROY(_filterPredicate);
	DESTROY(_allowedPickType);
	DESTROY(_allowedDropTypes);
	
	[super dealloc];
}

/** Returns a receiver copy with a nil content.

You can set the returned controller content indirectly with 
-[ETLayoutItemGroup setController:]. */
- (id) copyWithZone: (NSZone *)aZone
{
	ETController *newController = [[[self class] alloc] init];

	newController->_templateItem = [_templateItem copyWithZone: aZone];
	newController->_templateItemGroup = [_templateItemGroup copyWithZone: aZone];
	ASSIGN(newController->_objectClass, _objectClass);
	ASSIGN(newController->_groupClass, _groupClass);
	newController->_sortDescriptors = [_sortDescriptors copyWithZone: aZone];
	newController->_filterPredicate = [_filterPredicate copyWithZone: aZone];
	newController->_allowedPickType = [_allowedPickType copyWithZone: aZone];
	newController->_allowedDropTypes = [_allowedDropTypes mutableCopyWithZone: aZone];
	newController->_automaticallyRearrangesObjects = _automaticallyRearrangesObjects;
	newController->_hasNewSortDescriptors = (NO == [_sortDescriptors isEmpty]);
	newController->_hasNewFilterPredicate = (nil != _filterPredicate);
	newController->_hasNewContent = NO;

	return newController;
}

/** Returns the content object which is either a layout item group or nil.

See also -setContent: and -[ETLayoutItemGroup controller].*/
- (ETLayoutItemGroup *) content
{
	return _content;
}

/** You must use -[ETLayoutItem setController:] in your code and never this 
method which only exists to be used internally. 

Sets the content object that will be used as the base item for the layout 
item tree to be generated by this controller and put under its control.
 
The content must be nil or an ETLayoutItemGroup instance to be valid, otherwise
an invalid argument exception is raised. */
- (void) setContent: (ETLayoutItemGroup *)content
{
	BOOL notItemGroupKind = ([content isKindOfClass: [ETLayoutItemGroup class]] == NO);
	if (content != nil && notItemGroupKind)
	{
		[NSException raise: NSInvalidArgumentException format: @"-setContent: "
			"parameter %@ must be an ETLayoutItemGroup instance", content];
		return;
	}

	_content = content;
}

/** Returns the template item used to create leaf items. This template item
	is used as a prototype to make new layout items by 
	-[ETLayoutItemGroup newItem].
	This method returns nil by default and -[ETLayoutItemGroup newItem] will 
	simply create a new ETLayoutItem instance in such case. */
- (ETLayoutItem *) templateItem
{
	return _templateItem;
}

/** Returns the template item used to create branch items. This template item
	is used as a prototype to make new layout item groups by 
	-[ETLayoutItemGroup newItemGroup].
	This method returns nil by default and -[ETLayoutItemGroup newItemGroup] 
	will simply create a new ETLayoutItemGroup instance in such case. */
- (ETLayoutItemGroup *) templateItemGroup
{
	return _templateItemGroup;
}

/** Sets the template item used to create leaf items. This template item
	is used as a prototype to make new layout items by 
	-[ETLayoutItemGroup newItem].
	You can pass an instance of any ETLayoutItem class or subclass. */
- (void) setTemplateItem: (ETLayoutItem *)template
{
	ASSIGN(_templateItem, template);
}

/** Sets the template item used to create branch items. This template item
	is used as a prototype to make new layout item groups by 
	-[ETLayoutItemGroup newItemGroup].
	You can pass an instance of any ETLayoutItemGroup class or subclass. */
- (void) setTemplateItemGroup: (ETLayoutItemGroup *)template
{
	ASSIGN(_templateItemGroup, template);
}

/** Returns the class used to create model objects for leaf items. */
- (Class) objectClass
{
	return _objectClass;
}

/** Sets the class used to create model objects for leaf items.
	See also -newObject. */
- (void) setObjectClass: (Class)modelClass
{
	ASSIGN(_objectClass, modelClass);
}

/** Returns the group class used to create model objects for branch items.*/
- (Class) groupClass
{
	return _groupClass;
}
/** Sets the class used to create model objects for branch items.
	See also -newGroup. */
- (void) setGroupClass: (Class)modelClass
{
	ASSIGN(_groupClass, modelClass);
}

/** Creates and returns a new object that can be either a layout item clone of 
	-templateItem or a fresh instance of -objectClass. 
	If both a template item and an object class are set, the returned object 
	is a layout item with a new instance of -objectClass set as its 
	represented object. 
	This method is used by -add: and -insert: actions to generate the object 
	to be inserted into the content of the controller. 
	Take note that the autoboxing feature of -[ETLayoutItemGroup addObject:] 
	will take care of wrapping the created object into a layout item if needed. */
- (id) newObject
{
	id object = nil;

	if ([self templateItem] != nil)
	{
		object = [_content newItem]; /* Calls -templateItem */
	}

	if ([self objectClass] != nil)
	{
		id modelObject = AUTORELEASE([[[self objectClass] alloc] init]);

		if (object != nil)
		{
			[object setRepresentedObject: modelObject];
		}
		else
		{
			object = modelObject;
		}
	}

	return object;
}

/** Creates and returns a new object group that can be either a layout item 
	group clone of -templateItemGroup or a fresh instance of -groupClass. 
	If both a template item group and an group class are set, the returned 
	object is a layout item group with a new instance of -groupClass set as its 
	represented object. 
	This method is used by -addGroup: and -insertGroup: actions to generate the 
	object to be inserted into the content of the controller. 
	Take note that the autoboxing feature of -[ETLayoutItemGroup addObject:] 
	will take care of wrapping the created object into a layout item if needed. */
- (id) newGroup
{
	id object = nil;

	if ([self templateItemGroup] != nil)
	{
		object = [_content newItemGroup]; /* Calls -templateItemGroup */
	}

	if ([self groupClass] != nil)
	{
		id modelObject = AUTORELEASE([[[self groupClass] alloc] init]);

		if (object != nil)
		{
			[object setRepresentedObject: modelObject];
		}
		else
		{
			object = modelObject;
		}
	}

	return object;
}

/** Creates a new object by calling -newObject and adds it to the content. */
- (void) add: (id)sender
{
	[[self content] addObject: [self newObject]];
}

/** Creates a new object group by calling -newGroup and adds it to the content. */
- (void) addNewGroup: (id)sender
{
	[[self content] addObject: [self newGroup]];
}

/** Creates a new object by calling -newGroup and inserts it to the content at 
	-insertionIndex. */
- (void) insert: (id)sender
{
	[[self content] insertObject: [self newObject] 
	                     atIndex: [self insertionIndex]];
}

/** Creates a new object group by calling -newGroup and inserts it to the 
	content at -insertionIndex. */
- (void) insertNewGroup: (id)sender
{
	[[self content] insertObject: [self newGroup] 
	                     atIndex: [self insertionIndex]];
}

/** Removes all selected objects in the content. Selected objects are retrieved 
	by calling -selectedItemsInLayout on the content. */
- (void) remove: (id)sender
{
	NSArray *selectedItems = [[self content] selectedItemsInLayout];

	//ETLog(@"Will remove selected items %@", selectedItems);
	/* Removed items are temporarily retained by the array returned by 
	   -selectedItemsInLayout, therefore we can be sure we won't trigger the 
	   release of an already deallocated item. The typical case would be 
	   removing an item from a parent that was also selected and already got 
	   removed from the layout item tree. */
	[selectedItems makeObjectsPerformSelector: @selector(removeFromParent)];
}

/* Selection */

- (BOOL) setSelectionIndexes: (NSIndexSet *)selection
{
	[_content setSelectionIndexes: selection];
	return YES;
}

- (NSMutableIndexSet *) selectionIndexes
{
	return [_content selectionIndexes];
}
	
- (BOOL) setSelectionIndex: (unsigned int)index
{
	[_content setSelectionIndex: index];
	return YES;
}

- (unsigned int) selectionIndex
{
	return [_content selectionIndex];
}

/** Returns the position in the content, at which -insert: and -insertGroup: 
	will insert the object they create. The returned value is the last 
	selection index in the content. */
- (unsigned int) insertionIndex
{
	unsigned int index = [[[self content] selectionIndexes] lastIndex];

	/* No selection or no items */
	if (index == NSNotFound)
		index = [[self content] numberOfItems];

	return index;
}

/** Returns the sort descriptors used to sort the content associated with the 
receiver.

By default, returns an empty array. */
- (NSArray *) sortDescriptors
{
	return AUTORELEASE([_sortDescriptors copy]);
}

/** Set the sort descriptors used to sort the content associated with the 
receiver. */
- (void) setSortDescriptors: (NSArray *)sortDescriptors
{
	if (sortDescriptors != nil)
	{
		ASSIGNCOPY(_sortDescriptors, sortDescriptors);
	}
	else
	{
		_sortDescriptors = [[NSArray alloc] init];
	}
	_hasNewSortDescriptors = YES;
	if ([self automaticallyRearrangesObjects])
		[self rearrangeObjects];
}

/** Returns the search predicate to filter the controller content. */
- (NSPredicate *) filterPredicate
{
	return _filterPredicate;
}

/** Sets the search predicate to filter the controller content. */
- (void) setFilterPredicate: (NSPredicate *)searchPredicate
{
	ASSIGN(_filterPredicate, searchPredicate);
	_hasNewFilterPredicate = YES;
	if ([self automaticallyRearrangesObjects])
		[self rearrangeObjects];
}

/** Arranges the objects in the content by sorting them, then filtering them 
with -filterPredicate if the returned predicate is not nil. 

If the content is a tree structure, the entire tree is rearranged recursively 
by sorting and filtering each item group that get traversed.

You can override this method to implement another sort and filter strategy than 
the default one based on 
-[ETLayoutItemGroup sortWithSortDescriptors:recursively:], -sortDescriptors, 
-[ETLayoutItemGroup filterWithPredicate:recursively:] and -filterPredicate . */
- (void) rearrangeObjects
{
	if (_hasNewContent || _hasNewSortDescriptors)
		[_content sortWithSortDescriptors: [self sortDescriptors] recursively: YES];

	if (_hasNewContent || _hasNewFilterPredicate)
		[_content filterWithPredicate: [self filterPredicate] recursively: YES];

	if (_hasNewContent || _hasNewSortDescriptors || _hasNewFilterPredicate)
		[_content updateLayout];
}

/** Returns whether -rearrangeObjects should be automatically called when 
-setFilterPredicate: is called. */
- (BOOL) automaticallyRearrangesObjects
{
	return _automaticallyRearrangesObjects;
}

/** Sets whether -rearrangeObjects should be automatically called when 
-setFilterPredicate: is called. */
- (void) setAutomaticallyRearrangesObjects: (BOOL)flag
{
	_automaticallyRearrangesObjects = flag;
}

/* Not really needed */
// - (void) commitEditing
// {
// 	[[self content] reloadAndUpdateLayout];
// }

/* Pick and Drop */

- (ETUTI *) allowedPickType
{
	return _allowedPickType;
}

- (void) setAllowedPickType: (ETUTI *)aUTI
{
	NILARG_EXCEPTION_TEST(aUTI)
	ASSIGN(_allowedPickType, aUTI);
}

- (ETUTI *) allowedDropTypeForTargetType: (ETUTI *)aUTI
{
	NILARG_EXCEPTION_TEST(aUTI)
	NSMutableArray *matchedDropTypes = [NSMutableArray arrayWithCapacity: 100];

	FOREACH([_allowedDropTypes allKeys], targetType, ETUTI *)
	{
		if ([aUTI conformsToType: targetType])
		{
			[matchedDropTypes addObject: [_allowedDropTypes objectForKey: targetType]];
		}
	}

	return [ETUTI transientTypeWithSupertypes: matchedDropTypes];
}

- (void) setAllowedDropType: (ETUTI *)aUTI forTargetType: (ETUTI *)targetUTI
{
	NILARG_EXCEPTION_TEST(targetUTI)
	NILARG_EXCEPTION_TEST(aUTI)
	[_allowedDropTypes setObject: aUTI forKey: targetUTI];
}

@end

