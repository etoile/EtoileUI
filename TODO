TODO
====

Open Issues
-----------

- Write tests for -[ETController didChangeContent:toContent:]

- Retain delegates for all ETUIObject subclasses

	- Make persistency easier and safer

	- Means the delegate is owned as any other aspect
	
- Fix popup-button serialization 

	- We must extend view serialization to replace NSMenuItem.representedObject by the COObject.UUID or nil, and vice-versa (as we just do for NSControl.target)
	
- Add -testTableLayout to TestPersistency

- Factor out shared instance support duplicated in:

	- +[ETStyle/ETActionHandler sharedInstanceForObjectGraphContext:]
	- +[ETLayoutItemFactory itemFactoryWithObjectGraphContext:]
	
- Test +itemFactoryWithObjectGraphContext: and +sharedInstanceForObjectGraphContext:

- Fix disabled assertion about initialFocusedItem in ETWindowItem

- Add -referenceURL to COPersistentRoot, COBranch and COObject as an equivalent to COPath but including the store URL

	- Possible Format: coreobject://storeURL/?<persistentRootUUID>[/branchUUID[/objectUUID]] (the optional parts are encloded in [])
	
	- This referenceURL could be passed to -[ETDocumentController openItemWithURL:options:] and -[ETDocumentCreation initWithURL:options:]

- Improve UnitKit to support making the test suite the frontmost application (and then enable -testActiveItemChanged)

- Test that activating an application in background, results in the window group posting a  ETItemGroupSelectionDidChangeNotification

- Determine whether we want the main or key window as representing the selected item in the window group

	- The active item could represent the main window and the selected item the key window...
	
	- Could need to add -didChangeActiveItem to ETDocumentController when the main window changes. We could possibly live without and just react to the key window change, and testing whether the main window is the same or not... e.g. the controller subclass would a lastActiveItem property or use some similar approach (ETDocumentController subclass could cache the inspector item of the active item as we do Worktable)

- The object graph context in -provideWindowItem might have to change depending on how we implement ETWindowItem persistency

- Test that giving up key window status doesn't result in the initial focused item to be set next time the window becomes key

- Add -[TestWindowItem testWindowInitialFocusedItemAndToolActivationOnBecomeKey]

- Test synthesized enter and exit events

- Finish to rewrite the Object Inspector and do something about ETInspecting.h... discard or document

- Support dispatching actions on ETWindowItem or ETScrollableAreaItem. 

	- To do so, add -[ETDecoratorItem (backend)Responder] that returns either the window or scroll view and in -[ETApp targetForAction:from:to:] checks each decorator present in the responder chain for this backend responder
	
	- Or just reimplement the actions supported by NSWindow and NSScrollView in each decorator item class (and forward the messages to their Appkit representations)
	
- Finish cleaning NSView+EtoileUI


Old Potential Issues
--------------------

- Verify NSView hidden property doesn't cause a KVC error when read or written, it caused a crash in the object browser layout in the past.


GNUstep Things
--------------

- Implement NSBrowser keyed archiving on GNUstep (see NSView+EtoileUI)


# Basic Stuff

## Properties 

* Expose more properties for EtoileFoundation and EtoileUI classes.

* Handle read-only properties in a sane way, usually when no setter is available. A method like -isReadOnlyProperty: (NSString *)propertyName should be added to NSObject+Model in EtoileFoundation; not really sure this is the best method name though. We also need to update CoreObject related classes to use this same mechanism.

* See Refactoring for more properties related stuff.

# Refactoring

* Patch NSBitmapImageRep to avoid method collision with -valueForProperty:, probably rely on posing a subclass or a category and method swizzling


# New Features


## Drawing

* Implement rotation support for layout items without view, the code should be put in -[ETLayoutItemGroup display:dirtyRect:inView]

## Layout

* Implement shape-driven and pattern-driven layouts (a typical case is a grid layout)
ETShapeLayout
-initWithShape:

ETShape
ETPatternShape

# New Applications & Examples

## Generalize AZSwitch into a versatile Expose-like application that allows to navigate the windows with any EtoileUI layouts. AZSwitch can be seen as a subcase of such an application that only comes with an hardcoded ETTableLayout.

## Write a System-wide Shelf (also often referenced as Overlay Shelf) that runs in a standalone process. Involves to subclass ETPickboard in the Shelf code and modify +[ETPickboard systemPickboard] to return a DO proxy of the pickboard instance in the Shelf process. If we put aside collaboration features, a first implementation Shelf application should probably be around one hundred lines of code. Most of the code involves to override -insertItem:atIndex: and -removeItem: in the following spirit:

// layout items are received by ref through DO and -pushObject: should pass objects by ref too.
- (void) insertItem: (id)item atIndex: (int)index
{
	BOOL putProxyOnTheShelf = [item isMetaLayoutItem]; // a meta layout item is a UI proxy
	
	if (putProxyOnTheShelf) // picked a link (encompasses the lazy removal case when -shouldRemoveItemAtPickTime: returns NO)
	{
		[super insertItem: item atIndex: index]; // nothing to do in this case
	}
	else // picked an object or an object copy (aka cut and copy)
	{
		// The CoreObject implementation for this code is underway but far
		// from usable... the following is a very rough approach that will need
		// to be carefully refined.
		id modelObject = [item representedObject];

		if ([modelObject isManagedCoreObject] == NO)
			[CoreObject snapshot: [object representedObject] inLibrary: ShelfLibrary];
	
		[super insertItem: item atIndex: index];
	}
}

Then an ETOverlayShelfLayout could be created as an ETFreeLayout subclass to encapsulate the default UI of the Shelf in a pluggable layout.


# Long-term Experiments

## AppKit

### Modularize NSView to fully separate all the concerns (event handling, hierarchy/composite, drawing surface, responders)
