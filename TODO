TODO
====

Open Issues
-----------

- Write tests for -[ETController didChangeContent:toContent:]

- Retain delegates for all ETUIObject subclasses

	- Make persistency easier and safer

	- Means the delegate is owned as any other aspect
	
- Fix popup-button serialization 

	- We must extend view serialization to replace NSMenuItem.representedObject by the COObject.UUID or nil, and vice-versa (as we just do for NSControl.target)
	
- Add -testTableLayout to TestPersistency

- Factor out shared instance support duplicated in:

	- +[ETStyle/ETActionHandler sharedInstanceForObjectGraphContext:]
	- +[ETLayoutItemFactory itemFactoryWithObjectGraphContext:]
	
- Test +itemFactoryWithObjectGraphContext: and +sharedInstanceForObjectGraphContext:

- Fix disabled assertion about initialFocusedItem in ETWindowItem


Old Potential Issues
--------------------

- Verify NSView hidden property doesn't cause a KVC error when read or written, it caused a crash in the object browser layout in the past.


# Basic Stuff

## Properties 

* Expose more properties for Foundation, AppKit, EtoileFoundation and EtoileUI classes.

* Handle read-only properties in a sane way, usually when no setter is available. A method like -isReadOnlyProperty: (NSString *)propertyName should be added to NSObject+Model in EtoileFoundation; not really sure this is the best method name though. We also need to update CoreObject related classes to use this same mechanism.

* See Refactoring for more properties related stuff.

# Refactoring

* Patch NSBitmapImageRep to avoid method collision with -valueForProperty:, probably rely on posing a subclass or a category and method swizzling


# New Features


## Drawing

* Implement rotation support for layout items without view, the code should be put in -[ETLayoutItemGroup display:dirtyRect:inView]

## Layout

* Implement shape-driven and pattern-driven layouts (a typical case is a grid layout)
ETShapeLayout
-initWithShape:

ETShape
ETPatternShape

# New Applications & Examples

## Generalize AZSwitch into a versatile Expose-like application that allows to navigate the windows with any EtoileUI layouts. AZSwitch can be seen as a subcase of such an application that only comes with an hardcoded ETTableLayout.

## Write a System-wide Shelf (also often referenced as Overlay Shelf) that runs in a standalone process. Involves to subclass ETPickboard in the Shelf code and modify +[ETPickboard systemPickboard] to return a DO proxy of the pickboard instance in the Shelf process. If we put aside collaboration features, a first implementation Shelf application should probably be around one hundred lines of code. Most of the code involves to override -insertItem:atIndex: and -removeItem: in the following spirit:

// layout items are received by ref through DO and -pushObject: should pass objects by ref too.
- (void) insertItem: (id)item atIndex: (int)index
{
	BOOL putProxyOnTheShelf = [item isMetaLayoutItem]; // a meta layout item is a UI proxy
	
	if (putProxyOnTheShelf) // picked a link (encompasses the lazy removal case when -shouldRemoveItemAtPickTime: returns NO)
	{
		[super insertItem: item atIndex: index]; // nothing to do in this case
	}
	else // picked an object or an object copy (aka cut and copy)
	{
		// The CoreObject implementation for this code is underway but far
		// from usable... the following is a very rough approach that will need
		// to be carefully refined.
		id modelObject = [item representedObject];

		if ([modelObject isManagedCoreObject] == NO)
			[CoreObject snapshot: [object representedObject] inLibrary: ShelfLibrary];
	
		[super insertItem: item atIndex: index];
	}
}

Then an ETOverlayShelfLayout could be created as an ETFreeLayout subclass to encapsulate the default UI of the Shelf in a pluggable layout.


# Long-term Experiments

## AppKit

### Modularize NSView to fully separate all the concerns (event handling, hierarchy/composite, drawing surface, responders)
